# 第 1 章　データベースを制する者はシステムを制す

- RDBMS 以外にも当然いろんな DB の種類がある
  - KVS、ドキュメント型データベースなど
- 近年はデータ中心アプローチ（Data Oriented Approach：DOA）で開発されることが多い
  - これに対してプロセス中心アプローチ（Process Oriented Approach：POA）がある

# 第 2 章　論理設計と物理設計

- 三層スキーマは概ね以下の通り
  1. 外部スキーマ（外部モデル）＝ビューの世界
  2. 概念スキーマ（論理データモデル）＝テーブルの世界
  3. 内部スキーマ（物理データモデル）＝ファイルの世界
  - それぞれにデータ独立性があり、どれか一つの変更で済む
  - 概念スキーマはデータ独立性を保証するためにある
- 物理設計のステップは以下の通り
  1. テーブル定義
  2. インデックス定義
  3. ハードウェアのサイジング
  4. ストレージの冗長構成の決定
  5. ファイルの物理構造決定
- データベースの性能問題の 8 割はストレージ I/O によって起きる。
- サイジングはキャパシティとパフォーマンスの二つの観点から行なう。
- RAID0
  - ストライピング
  - データをストレージに分割保存する
  - 冗長性はない
  - クラウドは基本これ
- RAID1
  - ミラーリング
  - 冗長性はあるが性能が上がるわけではない
- RAID5
  - パリティ分散
  - 最低 3 本のストレージで行う
  - データ２つに対してそのパリティを 1 個用意する
- RAID10
  - ストライピングしたものをミラーリングする
- レプリケーションはトランザクションの更新情報を現用系（マスタ）から待機系（スレーブ）へ反映することで複製（レプリカ）を作成している。
- クラウドではストレージの冗長性を上げるのではなくレプリケーションを用いて冗長性を担保している
- データの復旧にはバックアップを反映させるリストアとトランザクションログを使って差分を再現するリカバリがある
  - トランザクションログは DBMS にも残っている
  - 1. フルバックアップのファイルをデータベースに戻す。
    - リストア
  - 2. 差分（または増分）バックアップしていたトランザクションログを適用する
    - リカバリ
  - 3. データベースサーバーに残っているトランザクションログを適用する。
    - ロールフォワード

ミック. 達人に学ぶ DB 設計徹底指南書 第 2 版 (p.130). 株式会社 翔泳社. Kindle 版.

# 第 3 章　論理設計と正規化　～なぜテーブルは分割するする必要があるのか？

- 「テーブル名はすべて複数形または集合名詞で書ける」
- テーブル名は英語ならば複数形／集合名詞で書ける。そうでなければそのテーブルにはどこか間違いがある。
- テーブルのセルに複数のデータを入れてはならない理由は関数従属がくずれるから
  - 主キーによってデータが一位に定まるという主キーの定義に反してしまう
- なるべく関数従属してるデータを切り離すと
  - INSERT するときにミスが減る
    - 関数従属が破壊されたデータ(部署 ID と部署名が違う)とかいうのがなくなる
    - 切り出しておけば不明なものを INSERT せずに済む
- 第 2 正規化というのは、言ってみれば「会社」と「社員」という、それぞれに異なるレベルの実体（エンティティ）を、きちんとテーブルとしても分離してやる作業
- ボイスコット正規形とは非キーからキーへの関数従属をなくしたもの
- テーブルの構成次第でアプリケーションロジックでのバグを減らすことができる
  - フラグがある場合にのみデータが存在する場合など
- 第四正規形は独立な 1:N(N は FK) の他値従属性が複数存在するテーブルを N 子個のテーブルに分割することで作られる
- 第五正規型は A->B、A->C という関連があるときに B->C というテーブルも作ること
- 色々あるが結局第三正規形まで抑えれば基本いい

# 第 4 章　 ER 図　～複数のテーブルの関係を表現する

- 他対他の関係を作ってはいけない
  - リレーションから辿れないため
  - そのための中間テーブル

# 第 5 章　論理設計とパフォーマンス　～正規化の欠点と非正規化

- 正規化とパフォーマンスはトレードオフ
- 非正規化は最後の手段

# 第 6 章　データベースとパフォーマンス

- インデックスの設定は以下の点から有利
  - アプリケーションのコードに影響を与えない（アプリケーション透過的）
  - テーブルのデータに影響を与えない（データ透過的）
  - それでいて性能改善の効果が大きい。
- むやみに全列にインデックスをはるインデックスショットガンはアンチパターン
- インデックスの設計方針
  - 大規模なテーブルに対して作成する
  - カーディナリティの高い列に作成する
  - SQL 文で WHERE 句の選択条件、または結合条件に使用されている列に作成する
- カーディナリティとは特定の列の値が、どのぐらいの種類の多さを持つか、ということを表わす概念
- 複合列に対してインデックスを作成する場合、カーディナリティは対象の複合列の組み合わせで考える
- 主キーおよび一意制約の列には作成不要
  - 自動で作成されるため
- tree インデックスは更新性能を劣化させる
  - 更新のたびにインデックスの更新も必要だから
- 定期的なメンテナンスを行なうことが望ましい
  - インデックスは、テーブルのデータが更新されていくと、長期的には構造が崩れて性能が劣化するため
- インデックス以外のチューニング
  - パーティション
  - ヒント句
  - パラレルクエリ
  - オンメモリ

# 第 7 章　論理設計のアンチパターン

- キーには可変長文字列を使ってはいけない

# 第 8 章　論理設計のグレーノウハウ

- データをシステム化するにはデータクレンジングをする必要がある

# 第 9 章　一歩進んだ論理設計　～ RDB で木構造を扱う

- 木構造の扱いはまだまだ未知数
- 隣接リストで再起共通表式を用いることで表現できる
  - 再帰共通表式は WITH 句で定義したテーブルを自己参照することで記述する
- 閉包テーブルモデルでも表現できる
  - もとのテーブルに tree_id を増やして親子関係を示したテーブルをつける
  - 閉包テーブルでは検索は容易で、更新は難しくはないがやや面倒。

# 感想

DB 設計の辞書を読んだという印象だった。こまったらこの本を読めばどうにかなりそうではあるが、実践向けかと言われればそうではないのかなという印象である。
BE エンジニアがどこかで読んでおけばいい一冊だが DB 設計を学びたい人が一発目に選ぶべき本ではないのかもしれない。一方で知識の引き出しとしてはいい知識が沢山あったのでそういう意味では学びになったのかなと思う。
